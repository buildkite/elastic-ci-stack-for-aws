#!/usr/bin/env ruby

require "bundler/inline"
require "date"
require "yaml"

gemfile do
  source "https://rubygems.org"

  gem "oga" # an xml parser is required by aws-sdk
  gem "aws-sdk-ec2"
  gem "ostruct"
  gem "logger"
  gem "base64"
end

def die(msg)
  $stderr.puts msg
  exit 1
end

MAX_DELETIONS = 100

Region = ARGV[0] || ENV["AWS_REGION"]
dry_run = ENV["DRY_RUN"]

die("region not found") if Region.nil? || Region == ""

client = Aws::EC2::Client.new(region: Region)

# Fetch all AMIs that we own in the current region
res = client.describe_images(owners: ["self"], include_deprecated: true)
all_images = []
res.images.each do |image|
   all_images << image
end

# Filter the list of AMIs down to just those that were published by the elastic stack
# pipeline. There might be other AMIs in this account, and we don't wantto mess with them
all_images.select! { |image|
  image.name.start_with?("buildkite-stack-") ||        # The name we used until mid 2019
  image.name.start_with?("buildkite-stack-linux-") ||  # The name we used for linux amd64/arm64 from mid 2019
  image.name.start_with?("buildkite-stack-windows-")   # The name we used for windows amd64 from mid 2019
}

# We'd like to process the images oldest to newest
all_images.sort_by! { |image| image.creation_date }

# Each AMI *can* be used in multiple elastic stack releases. It's rare, but it
# happens. This will extract the versions - if any - from the tags. If we find
# some, we look up the templates for those versions, and verify that this AMI
# is used there. If it is, customers might be using it, so we should keep it.
#
# If it's not, then we will fall through to our other checks for age, etc.
#
def get_stack_versions_from_tags(image)
  image.tags.select { |t| t.key.start_with?("Version:") }.map { |t| t.key[/^Version:(.+)$/, 1] }
end

# If we only deregister the AMI then we'll be left with orphaned snapshots and keep paying for storage. This
# extracts the snapshot IDs that the AMI is pointing at, so we can delete them as well
def get_snapshot_ids(image)
  image.block_device_mappings.map { |blk| blk.ebs&.snapshot_id }.compact
end

# Deregister an AMI, and delete any associated snapshots
def deregister_image(client, image, dry_run)
  snapshot_ids = get_snapshot_ids(image)
  tag = dry_run ? "[DRY RUN]" : ""

  puts "- #{tag} deregistering image #{image.image_id}"
  client.deregister_image({image_id: image.image_id}) unless dry_run

  snapshot_ids.each do |snapshot_id|
    puts "- #{tag} deleting snapshot #{snapshot_id}"
    client.delete_snapshot({ snapshot_id: snapshot_id }) unless dry_run
  end
end

# version => [ami_id]
@cfn_template_amis = {}

def cfn_template_amis(version)
  return @cfn_template_amis[version] if @cfn_template_amis.has_key?(version)

  ext = (version[1].to_i < 4 ? 'json' : 'yml')
  template_url = "https://buildkite-aws-stack.s3.us-east-1.amazonaws.com/#{version}/aws-stack.#{ext}"

  # JSON is a strict subset of YAML, so we can parse either as YAML!
  cfn = YAML.load(`curl #{template_url}`, permitted_classes: [Date])

  @cfn_template_amis[version] = cfn['Mappings']['AWSRegion2AMI'][Region].values
end

one_year_ago = Time.now - (60 * 60 * 24 * 365)
six_months_ago = Time.now - (60 * 60 * 24 * 184) # Jul+Aug+Sep+Oct+Nov+Dec = 184 days

counters = {
  deleted: 0,
  checked: 0,
  public: 0,
  shared: 0,
  created_recently: 0,
  launched_recently: 0,
  eligible_for_deletion: 0,
}

# Time to get down to business.
#
# Loop over each elastic stack AMI, skip over any that we want to keep, and anything else we can deregister
# and save some money

all_images.each do |image|
  versions = get_stack_versions_from_tags(image)

  puts "ID: #{image.image_id}, Name: #{image.name}, Created: #{image.creation_date}, Last Launched: #{image.last_launched_time}, Public: #{image.public}, Version Tags: #{versions}"

  counters[:checked] += 1

  if DateTime.parse(image.creation_date).to_time >= one_year_ago
    counters[:created_recently] += 1
    puts "- keep (created recently)\n\n"
    next
  end

  if image.last_launched_time && DateTime.parse(image.last_launched_time).to_time >= one_year_ago
    counters[:launched_recently] += 1
    puts "- keep (launched recently)\n\n"
    next
  end

  if versions.any?
    if image.public
      # The IsReleased and Version:* tags are not reliable indicators of whether an image is actually
      # referred to by CloudFormation templates.
      #
      # So we verify those that claim to be referred to by the public CloudFormation templates.
      #
      if versions.any? { |v| cfn_template_amis(v).include?(image.image_id) }
        counters[:public] += 1
        puts "- keep (publicly released version)\n\n"
        next
      end
    else
      # If we made it here, the image is Private. If it's shared with any other
      # accounts, keep it. If not, proceed with other checks.
      launch_permission_attr = client.describe_image_attribute({
        attribute: "launchPermission",
        image_id: image.image_id,
      }).to_h

      if launch_permission_attr[:launch_permissions].any? { |lp|  }
        counters[:shared] += 1
        puts "- keep (released version, shared with other AWS accounts)\n\n"
        next
      end
    end
  end

  if counters[:deleted] >= MAX_DELETIONS
    counters[:eligible_for_deletion] += 1
    puts "- deletion candidate, but we've reached MAX_DELETIONS (#{MAX_DELETIONS})\n\n"
    next
  end

  deregister_image(client, image, dry_run)
  counters[:deleted] += 1

  puts
  puts

end

operation = (dry_run ? "Dry run" : "Cleanup")
summary = %Q[## #{operation} complete for `#{Region}`

NB: This table lists the *primary* reason for deciding to keep an image. If there are multiple reasons (e.g. public AND created recently), only the first one is counted here.

| Checked | Deregistered | Eligible for deregistration | Created recently | Launched recently | Shared publicly | Shared privately |
|:-------:|:------------:|:---------------------------:|:---------------:|:----------------:|:----------------:|:-----------------:|
| #{counters[:checked]} | #{counters[:deleted]} | #{counters[:eligible_for_deletion]} | #{counters[:created_recently]} | #{counters[:launched_recently]} | #{counters[:public]} | #{counters[:shared]} |
]

puts summary

buildkite_agent_bin = nil

if system("command -v buildkite-agent")
  buildkite_agent_bin = 'buildkite-agent'
elsif File.exist?('/usr/bin/buildkite-agent')
  # If buildkite-agent is mounted in by the docker-compose plugin, this is where it will be.
  buildkite_agent_bin = '/usr/bin/buildkite-agent'
end

`#{buildkite_agent_bin} annotate --context sweep-#{Region} --style info '#{summary}'` unless buildkite_agent_bin.nil?
