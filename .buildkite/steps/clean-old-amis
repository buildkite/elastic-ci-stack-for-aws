#!/usr/bin/env ruby

require "bundler/inline"
require "date"

gemfile do
  source "https://rubygems.org"

  gem "oga" # an xml parser is required by aws-sdk
  gem "aws-sdk-ec2"
  gem "ostruct"
  gem "logger"
  gem "base64"
end

def die(msg)
  $stderr.puts msg
  exit 1
end

MAX_DELETIONS = 100

region = ARGV[0] || ENV["AWS_REGION"]
dry_run = ENV["DRY_RUN"]

die("region not found") if region.nil? || region == ""

client = Aws::EC2::Client.new(region: region)

# Fetch all AMIs that we own in the current region
res = client.describe_images(owners: ["self"], include_deprecated: true)
all_images = []
res.images.each do |image|
   all_images << image
end

# Filter the list of AMIs down to just those that were published by the elastic stack
# pipeline. There might be other AMIs in this account, and we don't wantto mess with them
all_images.select! { |image|
  image.name.start_with?("buildkite-stack-") ||        # The name we used until mid 2019
  image.name.start_with?("buildkite-stack-linux-") ||  # The name we used for linux amd64/arm64 from mid 2019
  image.name.start_with?("buildkite-stack-windows-")   # The name we used for windows amd64 from mid 2019
}

# We'd like to process the images oldest to newest
all_images.sort_by! { |image| image.creation_date }

# Each AMI *can* be used in multiple elastic stack releases. It's rare, but it happens. This will extract one
# of the versions - if any - from the tags. Enough to confirm this image is one we published in Cloud Formation
# templates on githib.com and customers might be using it
def get_stack_version_from_tags(image)
  image.tags.each do |tag|
    if tag.key.start_with?("Version:")
      return tag.key[/^Version:(.+)$/, 1]
    end
  end
  nil
end

# If we only deregister the AMI then we'll be left with orphaned snapshots and keep paying for storage. This
# extracts the snapshot IDs that the AMI is pointing at, so we can delete them as well
def get_snapshot_ids(image)
  image.block_device_mappings.map { |blk| blk.ebs&.snapshot_id }.compact
end

# Deregister an AMI, and delete any associated snapshots
def deregister_image(client, image, dry_run)
  snapshot_ids = get_snapshot_ids(image)
  tag = dry_run ? "[DRY RUN]" : ""

  puts "- #{tag} deregistering image #{image.image_id}"
  client.deregister_image({image_id: image.image_id}) unless dry_run

  snapshot_ids.each do |snapshot_id|
    puts "- #{tag} deleting snapshot #{snapshot_id}"
    client.delete_snapshot({ snapshot_id: snapshot_id }) unless dry_run
  end
end

one_year_ago = Time.now - (60 * 60 * 24 * 365)

counters = {
  deleted: 0,
  checked: 0,
  public: 0,
  shared: 0,
  created_recently: 0,
  launched_recently: 0,
  eligible_for_deletion: 0,
}

# Time to get down to business.
#
# Loop over each elastic stack AMI, skip over any that we want to keep, and anything else we can deregister
# and save some money

all_images.each do |image|
  puts "ID: #{image.image_id}, Name: #{image.name}, Created: #{image.creation_date}, Last Launched: #{image.last_launched_time}, Public: #{image.public}, Version Tag; #{get_stack_version_from_tags(image)}"

  counters[:checked] += 1

  if get_stack_version_from_tags(image)
    if image.public
      counters[:public] += 1
      puts "- keep (publicly released version)\n\n"
      next
    end

    # If we made it here, the image is Private. If it's shared with any other
    # accounts, keep it. If not, proceed with other checks.
    launch_permission_attr = client.describe_image_attribute({
      attribute: "launchPermission",
      image_id: image.image_id,
    }).to_h

    if launch_permission_attr[:launch_permissions].any?
      counters[:shared] += 1
      puts "- keep (released version, shared with other AWS accounts)\n\n"
      next
    end
  end

  if DateTime.parse(image.creation_date).to_time >= one_year_ago
    counters[:created_recently] += 1
    puts "- keep (created recently)\n\n"
    next
  end

  if image.last_launched_time && DateTime.parse(image.last_launched_time).to_time >= one_year_ago
    counters[:launched_recently] += 1
    puts "- keep (launched recently)\n\n"
    next
  end

  if counters[:deleted] >= MAX_DELETIONS
    counters[:eligible_for_deletion] += 1
    puts "- deletion candidate, but we've reached MAX_DELETIONS (#{MAX_DELETIONS})\n\n"
    next
  end

  deregister_image(client, image, dry_run)
  counters[:deleted] += 1

  puts
  puts

end

operation = (dry_run ? "Dry run" : "Cleanup")
summary = %Q[## #{operation} complete for `#{region}`

| Checked | Deregistered | Eligible for deregistration | Shared publicly | Shared privately | Created recently | Launched recently |
|:-------:|:------------:|:---------------------------:|:---------------:|:----------------:|:----------------:|:-----------------:|
| #{counters[:checked]} | #{counters[:deleted]} | #{counters[:eligible_for_deletion]} | #{counters[:public]} | #{counters[:shared]} | #{counters[:created_recently]} | #{counters[:launched_recently]} |
]

puts summary

if system("command -v buildkite-agent")
  `buildkite-agent annotate --context sweep-#{region} --style info '#{summary}'`
end
